<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Flappy Bird</title>
  <style>
    body {
      margin: 0;
      background-color: #000000;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100vh;
      font-family: sans-serif;
      /* Imagen de fondo del body */
      background-image: url('MATERIAL/back3.jpg');
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
      overflow: hidden; /* Evita barras de scroll */
    }

    /* --- ESTILOS PANTALLA DE CARGA --- */
    #loadingScreen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: #000; /* Fondo negro */
      display: flex; /* Visible por defecto */
      flex-direction: column; /* Para alinear texto y botón verticalmente */
      justify-content: center;
      align-items: center;
      z-index: 10000; /* Muy alto para estar encima de todo */
      color: white;
    }

    #loadingText {
      font-size: 2em;
      text-shadow: 2px 2px 4px #555;
      margin-bottom: 20px; /* Espacio antes del botón */
    }

    #acceptButton {
      padding: 12px 25px;
      font-size: 1.2em;
      background-color: #5e9e0b; /* Verde */
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      display: none; /* Oculto inicialmente */
      transition: background-color 0.2s ease;
    }

    #acceptButton:hover {
      background-color: #4c8208; /* Verde más oscuro */
    }
    /* --- FIN ESTILOS PANTALLA DE CARGA --- */

    canvas {
      display: block;
      max-width: 100%;
      max-height: 85vh;
      border: 1px solid #333;
      cursor: pointer; /* Indica que el canvas es clickeable */
      margin-bottom: 10px;
      /* --- NUEVO: Evitar resaltado al tocar/hacer clic --- */
      -webkit-tap-highlight-color: transparent; /* iOS/Android */
      outline: none; /* Quitar borde de foco */
      user-select: none; /* Evitar selección de texto */
      -webkit-user-select: none; /* Safari */
      -moz-user-select: none; /* Firefox */
      -ms-user-select: none; /* IE/Edge */
    }

    /* Contenedor para los textos de puntuación */
    #scoreContainer {
        position: absolute;
        top: 10px;
        left: 50%;
        transform: translateX(-50%); /* Centra el contenedor */
        display: flex;
        flex-direction: column;
        align-items: center;
        background-color: rgba(0, 0, 0, 0.3); /* Fondo semitransparente */
        padding: 5px 15px;
        border-radius: 10px;
        z-index: 10; /* Encima del canvas */
    }


    #score, #highScore, #lastScore {
      font-size: 18px; /* Ajusta tamaño */
      font-weight: bold;
      color: white;
      text-shadow: 1px 1px 3px #000;
      margin: 2px 0; /* Espacio entre textos */
    }
     #score { font-size: 22px; } /* Puntaje actual más grande */


    #gameOverModal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.7);
      display: none; /* Oculto por defecto */
      justify-content: center;
      align-items: center;
      z-index: 999;
    }

    .modal-content {
      background-color: white;
      padding: 30px;
      border-radius: 15px;
      text-align: center;
      box-shadow: 0 0 15px rgba(0,0,0,0.5);
      color: #333;
    }

    .modal-content h2 {
      margin-top: 0;
      margin-bottom: 20px;
      font-size: 28px;
    }

    #restartButton {
      padding: 10px 20px;
      font-size: 18px;
      background-color: #5e9e0b;
      color: white;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      transition: background-color 0.2s ease;
    }

    #restartButton:hover {
      background-color: #4c8208;
    }

    /* Contenedor para botones inferiores */
    #bottomControls {
        position: fixed;
        bottom: 15px; /* Más cerca del borde */
        left: 0;
        width: 100%;
        display: flex;
        justify-content: space-between; /* Espacia los botones */
        padding: 0 20px; /* Padding lateral */
        box-sizing: border-box; /* Incluye padding en el ancho */
        z-index: 1000;
    }


    #skinMenuButton, #closeButton button {
        padding: 10px 15px; /* Ajusta padding */
        font-size: 18px; /* Iconos más grandes */
        border: none;
        border-radius: 50%; /* Botones redondos */
        cursor: pointer;
        box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        transition: transform 0.1s ease, box-shadow 0.1s ease;
    }
     #skinMenuButton {
         background-color: #0077ff; /* Azul */
         color: white;
     }
     #closeButton button {
         background-color: #e00b0b; /* Rojo */
         color: white;
     }

     #skinMenuButton:active, #closeButton button:active {
         transform: scale(0.9);
         box-shadow: 0 1px 2px rgba(0,0,0,0.2);
     }

    #skinMenu {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: rgba(0,0,0,0.85);
      padding: 25px;
      border-radius: 12px;
      display: none; /* Oculto por defecto */
      flex-wrap: wrap;
      justify-content: center;
      gap: 15px;
      z-index: 1001;
      border: 2px solid #444;
    }

    .skin-option {
      width: 60px;
      height: 60px;
      border-radius: 10px;
      overflow: hidden;
      cursor: pointer;
      border: 2px solid white;
      transition: transform 0.2s ease, border-color 0.2s ease;
      position: relative; /* Para el tooltip */
    }
    .skin-option:hover {
        transform: scale(1.1);
        border-color: #00ff00;
    }

    .skin-option img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block; /* Evita espacio extra bajo la imagen */
    }

    .locked {
      filter: grayscale(100%) brightness(0.6); /* Más oscuro y gris */
      opacity: 0.6;
      cursor: not-allowed;
      border-color: #555; /* Borde gris para bloqueados */
    }
     .locked:hover {
         transform: none; /* Sin efecto hover en bloqueados */
         border-color: #555;
     }

    /* Tooltip para skins bloqueadas */
    .locked::after {
        content: attr(data-unlock-score); /* Muestra el puntaje necesario */
        position: absolute;
        bottom: -25px; /* Posición bajo el icono */
        left: 50%;
        transform: translateX(-50%);
        background-color: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 3px 8px;
        border-radius: 4px;
        font-size: 12px;
        white-space: nowrap;
        opacity: 0; /* Oculto por defecto */
        transition: opacity 0.2s ease;
        pointer-events: none; /* No interfiere con clics */
    }
    .locked:hover::after {
        opacity: 1; /* Mostrar tooltip en hover */
    }


    /* Créditos */
    #credits {
        position: fixed;
        bottom: 65px; /* Encima de los botones inferiores */
        left: 50%;
        transform: translateX(-50%);
        color: rgba(255, 255, 255, 0.7); /* Blanco semitransparente */
        font-size: 12px;
        text-shadow: 1px 1px 2px #000;
        z-index: 1000;
    }

  </style>
</head>
<body>
  <div id="loadingScreen">
    <p id="loadingText">Cargando...</p>
    <button id="acceptButton">Aceptar</button>
  </div>

  <div id="scoreContainer">
      <div id="score">Puntaje: 0</div>
      <div id="highScore">Mejor: 0</div>
      <div id="lastScore">Último: 0</div>
  </div>

  <canvas id="gameCanvas" width="340" height="580"></canvas>

  <div id="skinMenu"></div>

  <div id="bottomControls">
       <button id="skinMenuButton" title="Cambiar Skin">🏁</button>
       <a href="panel.html" id="closeButton" title="Volver al Panel">
           <button>🎲</button>
       </a>
   </div>

  <p id="credits">Hecho por Moises Navarrete</p>

  <div id="gameOverModal">
    <div class="modal-content">
      <h2>¡Has Muerto!</h2>
      <button id="restartButton">Respawn</button>
    </div>
  </div>

  <script>
    // --- REFERENCIAS A ELEMENTOS DEL DOM ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreDisplay = document.getElementById('score');
    const highScoreDisplay = document.getElementById('highScore');
    const lastScoreDisplay = document.getElementById('lastScore');
    const loadingScreen = document.getElementById('loadingScreen');
    const loadingText = document.getElementById('loadingText');
    const acceptButton = document.getElementById('acceptButton');
    const skinMenu = document.getElementById('skinMenu');
    const skinMenuButton = document.getElementById('skinMenuButton');
    const gameOverModal = document.getElementById('gameOverModal');
    const restartButton = document.getElementById('restartButton');
    const closeButton = document.getElementById('closeButton');

    // --- CONFIGURACIÓN DEL JUEGO ---
    const playerName = 'Jugador1';
    const gravity = 0.2;
    const jumpStrength = -4.5;
    const birdX = 70;
    const birdWidth = 40;
    const birdHeight = 40;
    const pipeWidth = 50;
    const pipeGap = 140;
    const obstacleSpeed = 2.5;
    const spawnRate = 100;

    // --- VARIABLES DE ESTADO DEL JUEGO ---
    let birdY = canvas.height / 3;
    let birdVelocity = 0;
    let obstacles = [];
    let frame = 0;
    let score = 0;
    let highScore = parseInt(localStorage.getItem(`${playerName}_flappyHighScore`)) || 0;
    let lastScoreValue = parseInt(localStorage.getItem(`${playerName}_flappyLastScore`)) || 0;
    let gameOver = false;
    let gameStarted = false;
    let animationFrameId = null;

    // --- RECURSOS (IMÁGENES Y AUDIO) ---
    const backgroundImage = new Image();
    const birdImage = new Image(); // Esta se actualizará dinámicamente
    const pipeImage = new Image();
    const birdDeathImageSrc = 'MATERIAL/b2.png'; // Guarda la ruta de la imagen de muerte

    const backgroundMusic = new Audio();
    const deathSound = new Audio();
    const jumpSound = new Audio();
    const pointSound = new Audio();

    // --- GESTIÓN DE CARGA DE RECURSOS ---
    const assetsToLoad = [
      { type: 'image', element: backgroundImage, src: "MATERIAL/back55.png" },
      { type: 'image', element: birdImage, src: null }, // Skin inicial se carga en loadAssets
      { type: 'image', element: pipeImage, src: "MATERIAL/tubo4.png" },
      // Precargar imagen de muerte (opcional pero recomendado)
      { type: 'image', element: new Image(), src: birdDeathImageSrc },
      { type: 'audio', element: backgroundMusic, src: 'MATERIAL/MI.MP3' },
      { type: 'audio', element: deathSound, src: 'MATERIAL/HIT2.MP3' },
      { type: 'audio', element: jumpSound, src: 'MATERIAL/salto1.MP3' },
      // { type: 'audio', element: pointSound, src: 'MATERIAL/point.mp3' }
    ];

    let assetsLoadedCount = 0;
    const totalAssets = assetsToLoad.length;

    function assetLoadedCallback(asset) {
      assetsLoadedCount++;
      const percentage = Math.round((assetsLoadedCount / totalAssets) * 100);
      const displayPercentage = Math.min(percentage, 100);
      loadingText.textContent = `Cargando... ${displayPercentage}%`;
      console.log(`Recurso cargado: ${asset.src || asset.element?.id || 'unknown'} (${assetsLoadedCount}/${totalAssets})`);

      if (assetsLoadedCount >= totalAssets) {
        console.log("Todos los recursos cargados.");
        loadingText.style.display = 'none';
        acceptButton.style.display = 'block';
        acceptButton.addEventListener('click', startGameAfterLoading, { once: true });
      }
    }

    function startGameAfterLoading() {
        loadingScreen.style.display = 'none';
        updateScoreDisplays();
        drawInitialScreen();
    }


    function loadAssets() {
      console.log("Iniciando carga de recursos...");
      loadingText.textContent = 'Cargando... 0%';

      // Cargar skin inicial para birdImage ANTES de añadir listeners
      const savedSkin = localStorage.getItem(`${playerName}_selectedSkin`) || 'b1.png';
      const birdImageSrc = `MATERIAL/${savedSkin}`;
      // Encuentra el asset de birdImage y asigna el src
      const birdAsset = assetsToLoad.find(a => a.element === birdImage);
      if (birdAsset) {
          birdAsset.src = birdImageSrc; // Actualiza el src en la lista
          birdImage.src = birdImageSrc; // Asigna src al elemento Image real
      } else {
          console.error("No se encontró el asset de birdImage en assetsToLoad");
          // Como fallback, carga la imagen directamente, pero no se contará en la carga
          birdImage.src = birdImageSrc;
      }


      assetsToLoad.forEach(asset => {
        const element = asset.element;

        // Asignar SRC si es necesario (y no es el birdImage que ya tiene src)
        if (asset.type === 'image' && asset.src && element !== birdImage) {
            element.src = asset.src;
        } else if (asset.type === 'audio') {
            element.src = asset.src;
            element.preload = 'auto';
        }

        // Añadir listeners (incluso para birdImage, ahora que tiene src)
        if (asset.type === 'image') {
          // Comprobar si ya está completa (caché)
          if (element.complete) {
            // Contar de inmediato si ya está cargada
            // Usar setTimeout para evitar problemas de sincronización
            setTimeout(() => assetLoadedCallback(asset), 0);
          } else {
            // Añadir listeners de carga y error
            element.onload = () => assetLoadedCallback(asset);
            element.onerror = () => {
              console.error(`Error cargando imagen: ${element.src}`);
              assetLoadedCallback(asset); // Contar igual para no bloquear
            };
          }
        } else if (asset.type === 'audio') {
          element.addEventListener('canplaythrough', () => assetLoadedCallback(asset), { once: true });
          element.addEventListener('error', (e) => {
            console.error(`Error cargando audio: ${element.src}`, e);
            assetLoadedCallback(asset);
          }, { once: true });
          element.load(); // Iniciar carga explícitamente
        }
      });
    }
    // --- FIN GESTIÓN DE CARGA ---

    // --- FUNCIONES PRINCIPALES DEL JUEGO ---

    function updateScoreDisplays() {
        scoreDisplay.textContent = `Puntaje: ${score}`;
        highScoreDisplay.textContent = `Mejor: ${highScore}`;
        lastScoreDisplay.textContent = `Último: ${lastScoreValue}`;
    }

    function resetGame() {
      lastScoreValue = score;
      localStorage.setItem(`${playerName}_flappyLastScore`, lastScoreValue);

      if (score > highScore) {
        highScore = score;
        localStorage.setItem(`${playerName}_flappyHighScore`, highScore);
      }

      birdY = canvas.height / 3;
      birdVelocity = 0;
      obstacles = [];
      frame = 0;
      score = 0;
      gameOver = false;
      gameStarted = false;

      updateScoreDisplays();

      // IMPORTANTE: Resetear a la skin seleccionada, no a la de muerte
      const currentSkin = localStorage.getItem(`${playerName}_selectedSkin`) || 'b1.png';
      birdImage.src = `MATERIAL/${currentSkin}`; // Asegura usar la skin correcta

      backgroundMusic.pause();
      backgroundMusic.currentTime = 0;

      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
      }

      drawInitialScreen(); // Dibuja el estado reseteado
      gameOverModal.style.display = 'none';
    }

    function drawInitialScreen() {
      drawBackground();
      drawBird(); // Dibuja el pájaro con la skin seleccionada/inicial
    }

    function drawBackground() {
      ctx.drawImage(backgroundImage, 0, 0, canvas.width, canvas.height);
    }

    function drawBird() {
      // Dibuja la imagen actual de birdImage (puede ser skin normal o de muerte)
      ctx.drawImage(birdImage, birdX - birdWidth / 2, birdY - birdHeight / 2, birdWidth, birdHeight);
    }

    function drawObstacles() {
        obstacles.forEach(ob => {
            // Tubería Superior
            let yTop = ob.top;
            while (yTop > 0) {
                const segmentHeight = Math.min(pipeImage.height, yTop);
                ctx.save();
                ctx.translate(ob.x + pipeWidth / 2, yTop - segmentHeight / 2);
                ctx.scale(1, -1);
                ctx.drawImage(pipeImage, -pipeWidth / 2, -segmentHeight / 2, pipeWidth, segmentHeight);
                ctx.restore();
                yTop -= segmentHeight;
            }
            // Tubería Inferior
            let yBottom = ob.bottomY;
            let remainingHeight = canvas.height - yBottom;
            while (remainingHeight > 0) {
                const segmentHeight = Math.min(pipeImage.height, remainingHeight);
                ctx.drawImage(pipeImage, ob.x, yBottom, pipeWidth, segmentHeight);
                yBottom += segmentHeight;
                remainingHeight -= segmentHeight;
            }
        });
    }


    function updateObstacles() {
      if (frame % spawnRate === 0) {
        const minTop = 60;
        const maxTop = canvas.height - pipeGap - 60;
        const topPipeHeight = Math.random() * (maxTop - minTop) + minTop;
        obstacles.push({
          x: canvas.width, width: pipeWidth, top: topPipeHeight,
          bottomY: topPipeHeight + pipeGap, passed: false
        });
      }
      obstacles.forEach(ob => {
        ob.x -= obstacleSpeed;
        if (!ob.passed && ob.x + ob.width < birdX - birdWidth / 2) {
          ob.passed = true; score++;
          scoreDisplay.textContent = `Puntaje: ${score}`;
          // pointSound.play();
        }
      });
      obstacles = obstacles.filter(ob => ob.x + ob.width > 0);
    }

    function checkCollision() {
        const birdRadius = birdWidth / 2 - 5;
        const birdLeft = birdX - birdRadius;
        const birdRight = birdX + birdRadius;
        const birdTop = birdY - birdRadius;
        const birdBottom = birdY + birdRadius;

        if (birdBottom > canvas.height || birdTop < 0) return true;

        for (let ob of obstacles) {
            const pipeRight = ob.x + ob.width;
            if (birdRight > ob.x && birdLeft < pipeRight) {
                if (birdTop < ob.top || birdBottom > ob.bottomY) return true;
            }
        }
        return false;
    }

    function gameLoop() {
        if (gameOver) return;

        drawBackground();
        updateObstacles();
        drawObstacles();
        birdVelocity += gravity;
        birdY += birdVelocity;
        // Dibujar el pájaro ANTES de chequear colisión en esta iteración
        drawBird();

        // Chequear colisión DESPUÉS de mover y dibujar todo
        if (checkCollision()) {
            gameOver = true;
            // --- NUEVO: Cambiar imagen y redibujar ---
            birdImage.src = birdDeathImageSrc; // Cambia a imagen de muerte
            drawBird(); // Dibuja inmediatamente la imagen de muerte en la última posición
            // --- Fin Nuevo ---
            deathSound.play();
            backgroundMusic.pause();
            // Mostrar modal DESPUÉS de redibujar el pájaro muerto
            gameOverModal.style.display = 'flex';
            // Detener el bucle aquí
            return;
        }

        frame++;
        animationFrameId = requestAnimationFrame(gameLoop);
    }

    function jump() {
        if (gameOver || loadingScreen.style.display !== 'none') return;

        if (!gameStarted) {
            gameStarted = true;
            birdVelocity = 0;
            backgroundMusic.loop = true;
            backgroundMusic.volume = 0.5;
            backgroundMusic.play();
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            gameLoop();
        }

        birdVelocity = jumpStrength;
        jumpSound.play();
    }

    // --- EVENT LISTENERS ---
    canvas.addEventListener('click', jump);
    window.addEventListener('keydown', (e) => {
        if (e.code === 'Space') { e.preventDefault(); jump(); }
    });
    restartButton.addEventListener('click', resetGame);
    closeButton.addEventListener('click', (e) => { deathSound.play(); });

    // --- SKIN SYSTEM ---
    const skins = [
      { file: 'b1.png', unlockScore: 0 },
      { file: 'b22.png', unlockScore: 100 }, // Asegúrate que este archivo exista
      { file: 'b3.png', unlockScore: 150 },
      { file: 'b4.png', unlockScore: 200 }
    ];

    skinMenuButton.addEventListener('click', () => {
        const isVisible = skinMenu.style.display === 'flex';
        skinMenu.style.display = isVisible ? 'none' : 'flex';
        if (!isVisible) loadSkins();
    });

    function loadSkins() {
        skinMenu.innerHTML = '';
        const currentHighScore = parseInt(localStorage.getItem(`${playerName}_flappyHighScore`)) || 0;
        skins.forEach(skin => {
            const div = document.createElement('div');
            div.classList.add('skin-option');
            const isLocked = currentHighScore < skin.unlockScore;
            const img = document.createElement('img');
            img.src = `MATERIAL/${skin.file}`;
            img.alt = `Skin ${skin.file.split('.')[0]}`;
            div.appendChild(img);
            if (isLocked) {
                div.classList.add('locked');
                div.setAttribute('data-unlock-score', `Necesitas ${skin.unlockScore} pts`);
                div.style.cursor = 'not-allowed';
            } else {
                div.addEventListener('click', () => {
                    localStorage.setItem(`${playerName}_selectedSkin`, skin.file);
                    birdImage.src = `MATERIAL/${skin.file}`; // Cambia imagen actual
                    if (!gameStarted && !gameOver) drawInitialScreen(); // Redibuja si el juego no ha empezado
                    skinMenu.style.display = 'none';
                });
            }
            skinMenu.appendChild(div);
        });
    }

    // --- INICIO ---
    loadAssets();

  </script>
</body>
</html>


